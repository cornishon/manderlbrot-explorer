#version 430

#ifndef MAX_ITER
#define MAX_ITER 400
#endif

#ifndef CELL_SIZE
#define CELL_SIZE 8
#endif

layout(local_size_x = CELL_SIZE, local_size_y = CELL_SIZE, local_size_z = 1) in;

layout(set = 1, binding = 0, rgba32f) uniform writeonly image2D img;
layout(set = 2, binding = 0, std140) uniform ViewBox {
    dvec2 min_bounds;
    dvec2 max_bounds;
};

dvec2 remap(dvec2 old_value, dvec2 old_min, dvec2 old_max, dvec2 new_min, dvec2 new_max) {
    dvec2 old_range = old_max - old_min;
    dvec2 new_range = new_max - new_min;
    return ((old_value - old_min) / old_range) * new_range + new_min;
}

// All components are in the range [0â€¦1], including hue.
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    dvec2 c = remap(gl_GlobalInvocationID.xy, dvec2(0), imageSize(img), min_bounds, max_bounds);
    dvec2 z = dvec2(0);

    float i;
    for (i = 0.0; dot(z, z) < 4.0 && i < MAX_ITER; i += 1.0) {
        double rr = z.x * z.x;
        double ii = z.y * z.y;
        double ri = z.x * z.y;
        z = dvec2(rr - ii, ri + ri) + c;
    }

    vec3 color = vec3(0);
    if (i < MAX_ITER) {
        float k = i / MAX_ITER;
        float hue = mod(pow(k, 1.5) + 0.64, 1.0);
        color = hsv2rgb(vec3(hue, 1.0, k));
    }

    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    imageStore(img, coord, vec4(color, 1.0));
}

