#version 430

#ifndef CELL_SIZE
#define CELL_SIZE 8
#endif

layout(local_size_x = CELL_SIZE, local_size_y = CELL_SIZE, local_size_z = 1) in;

layout(set = 1, binding = 0, rgba32f) uniform writeonly image2D img;
layout(set = 2, binding = 0, std140) uniform ViewBox {
    vec2 min_bounds;
    vec2 max_bounds;
};

vec2 remap(vec2 old_value, vec2 old_min, vec2 old_max, vec2 new_min, vec2 new_max) {
    vec2 old_range = old_max - old_min;
    vec2 new_range = new_max - new_min;
    return ((old_value - old_min) / old_range) * new_range + new_min;
}

// All components are in the range [0â€¦1], including hue.
vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    vec2 c = remap(gl_GlobalInvocationID.xy, vec2(0), imageSize(img), min_bounds, max_bounds);

    vec2 z = vec2(0.0, 0.0);
    float i;
    for (i = 0.0; dot(z, z) < 4.0 && i < 1.0; i += 0.002) {
        float rr = z.x * z.x;
        float ii = z.y * z.y;
        float ri = z.x * z.y;
        z = vec2(rr - ii, ri + ri) + c;
    }

    vec3 hsv = vec3(mod(pow(i, 1.5) + 0.64, 1.0), 1, i);
    vec4 color = vec4(hsv2rgb(hsv), 1.0);
    vec2 coord = gl_GlobalInvocationID.xy;
    imageStore(img, ivec2(coord), color);
}

